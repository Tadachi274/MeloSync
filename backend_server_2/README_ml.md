# 感情転移に基づく音楽推薦システム

## 1. 概要

多くの人々は、気分を管理したり、特定の感情状態に至るために音楽を聴きます。このプロジェクトは、単に「幸せな曲」を推薦するのではなく、「ユーザーが現在の感情（例：悲しみ）から目標の感情（例：リラックス）へ移る」ことを統計的に助ける確率が最も高い楽曲を推薦することを目的とした、高度な推薦システムです。

Spotify APIから取得した楽曲のオーディオ特徴量を入力とし、ユーザーの聴取ログから生成した「感情転移確率」を教師データとして、多出力ニューラルネットワークを学習させることで、この機能を実現します。

**使用技術:** Python, Pandas, Scikit-learn, TensorFlow (Keras), Spotipy

---

## 2. システムの核となる概念：感情転移行列

このシステムの最もユニークな特徴は、各楽曲に**4x4の感情転移確率行列**をラベルとして定義することです。

-   **行列の構造**:
    -   **行**: 音楽を聴き始める前の「開始感情」（0: Angry, 1: Happy, 2: Relaxed, 3: Sad）
    -   **列**: 音楽を聴き終えた後の「終了感情」（0: Angry, 1: Happy, 2: Relaxed, 3: Sad）
    -   **値**: その曲を聴いた結果、行の感情から列の感情へ遷移する確率。

-   **具体例**:
    -   ある曲の行列で、`matrix[3][1]` の値が `0.7` であった場合、それは「悲しい(Sad)時にその曲を聴くと、70%の確率で幸せ(Happy)な気分になる」ことを意味します。

-   **生成方法**:
    -   この行列は、`label_processing.py` によって、多数のユーザーから集めた「この曲を聴いたら、この感情からこの感情に変わった」という遷移ログを集計し、各開始感情ごとに確率（合計が1になるよう）を正規化することで生成されます。

---

## 3. システムアーキテクチャと処理フロー

本システムは `main.py` をエントリーポイントとして、以下のステップで処理が実行されます。

1.  **データ収集 (`main.py`)**
    -   ユーザーの感情遷移ログ（開始感情、終了感情、Spotify URL）が含まれる`melosync_music_data.csv`を読み込みます。

2.  **特徴量取得 (`spotify_api.py`)**
    -   CSV内のSpotify URLを基に、Spotify APIへアクセスし、各楽曲のダンス可能性、エネルギー、テンポなどのオーディオ特徴量を取得します。

3.  **ラベル生成 (`label_processing.py`)**
    -   収集した遷移ログを基に、システムの核である「4x4感情転移確率行列」を楽曲ごとに計算し、モデルの教師データ（正解ラベル）を生成します。

4.  **特徴量エンジニアリング (`feature_engineering.py`)**
    -   取得したオーディオ特徴量をモデルが学習しやすい形式に変換します。数値データは標準化（StandardScaler）し、キーなどのカテゴリデータはワンホットエンコーディングします。

5.  **モデル学習 (`model.py`)**
    -   加工された特徴量を入力（X）、生成された感情転移確率を入力（Y）として、多出力ニューラルネットワークを学習させます。モデルは、楽曲の特徴からその曲が持つ感情遷移の可能性を予測できるように訓練されます。

6.  **推薦生成 (`recommend.py`)**
    -   学習済みモデルを利用します。ユーザーが現在の`start_mood`と目標の`target_mood`を指定すると、システムは全楽曲に対してその遷移確率を予測し、確率が最も高い順に楽曲を推薦します。

---

## 4. ディレクトリ構成
backend_server/
├─ data/                   # (入力) melosync_music_data.csv などのデータセットを格納
├─ spotify_api.py          # Spotify APIからオーディオ特徴量を取得するモジュール
├─ feature_engineering.py  # 特徴量の標準化やエンコーディングを行うモジュール
├─ label_processing.py     # 感情転移確率行列（ラベル）を生成するコアモジュール
├─ model.py                # 多出力ニューラルネットワークモデルを定義するモジュール
├─ recommend.py            # 学習済みモデルを使い、楽曲を推薦するロジックを実装
├─ main.py                 # 全ての処理フローを制御するメインスクリプト
├─ requirements.txt        # プロジェクトの依存ライブラリ一覧
└─ README.md               # このファイル

---

## 5. セットアップと実行方法

### 前提条件
-   Python 3.8 以降

### インストール手順

1.  **リポジトリをクローン:**
    ```bash
    git clone [https://github.com/your-username/your-repository.git](https://github.com/your-username/your-repository.git)
    cd backend_server
    ```

2.  **依存ライブラリのインストール:**
    ```bash
    pip install -r requirements.txt
    ```

### 設定

1.  **Spotify API認証情報の設定**
    -   Spotify Developer Dashboard (https://developer.spotify.com/dashboard/) でアプリケーションを作成し、`Client ID` と `Client Secret` を取得します。
    -   `main.py` ファイルを開き、取得した情報を以下のように設定します。
    ```python
    # main.py
    CLIENT_ID = 'あなたのClient IDをここにペースト'
    CLIENT_SECRET = 'あなたのClient Secretをここにペースト'
    ```

2.  **入力データの配置**
    -   `data` ディレクトリ内に、感情遷移ログを含む `melosync_music_data.csv` ファイルを配置してください。

### 実行

-   全ての設定が完了したら、以下のコマンドでプロジェクトを実行します。
    ```bash
    python main.py
    ```
-   実行すると、コンソールにAPIからのデータ取得状況、モデルの学習過程、そして最後に推薦結果の例が出力されます。

---

## 6. 各モジュールの詳細解説

-   **`main.py`**
    -   プロジェクト全体のオーケストレーター。データ読み込みから、特徴量取得、モデル学習、最終的な推薦まで、各モジュールを正しい順序で呼び出す役割を担います。

-   **`spotify_api.py`**
    -   `spotipy`ライブラリの中核。`fetch_audio_features`関数は、APIへの過負荷を避けるためのバッチ処理と、一時的なエラーに対応するための再試行ロジックを備えています。

-   **`label_processing.py`**
    -   `pandas`の強力なデータ操作機能（特に`groupby().unstack()`）を活用し、生の遷移ログからクリーンな確率行列（モデルの教師データ）を生成する、本プロジェクトで最も重要なデータ処理モジュールです。

-   **`feature_engineering.py`**
    -   機械学習の前処理におけるベストプラクティスを実装。`StandardScaler`は特徴量間のスケールの違いを吸収し、モデルの学習を安定させます。`one-hot_encode`は、数値的な順序関係のないカテゴリデータをモデルが扱える形式に変換します。

-   **`model.py`**
    -   TensorFlow/Kerasを用いてニューラルネットワークを定義。この問題は「1つの入力から4つの異なる確率分布を予測する」ため、4つの独立した`softmax`活性化関数を持つ出力層で構成される**多出力モデル**が採用されています。`Dropout`層は、モデルが訓練データに過剰に適合（過学習）するのを防ぎます。

-   **`recommend.py`**
    -   シンプルかつ効果的な推薦ロジック。`model.predict()`で得られる予測結果（4つの出力層からのリスト）から、ユーザーの`start_mood`に対応する部分だけを選択し、その中で`target_mood`の確率が最も高いものを探します。

---
